```javascript
{
"title": "mysql缓存",
"author": "douyacun",
"date": "2019-01-14",
}
```

- MySQL如何命中缓存
- 查询缓存如何使用内存
- 什么情况下查询缓存能发挥作用
- 如何配置和维护查询缓存
- 通用查询缓存优化

MySQL 查询保存完整的查询结果，当该查询命中缓存，mysql 会立刻返回该结果，跳过解析、优化、执行阶段

# mysql 如何命中缓存

缓存存放在一个引用表中,通过hash值引用，这个hash值包含一下因素：
- 查询本身
- 当前要查询的数据库
- 客户端协议版本

判读缓存是否命中时：mysql直接使用sql和和客户端发送过来的信息比对，任何字符上的不同 都会导致缓存不命中

当查询中存在不确定数据时，结果也不会缓存，包含用户自定义函数，存储函数，用户变量，包含任何列级别权限的表都不会缓存

在检查缓存之前mysql只做一件事：检查sql是否以`sel`开头

缓存对读和写都会带来消耗：
- 读开始之前必须检查是否命中缓存
- 如果这个读查询可以被缓存，若发现没有这个缓存，会将结果缓存到内存中，会带来额外的消耗
- 当向某个表写入时，必须使这个表的所有缓存都失效，如果查询缓存特别大或者缓存特别多，可能会带来很大的系统消耗

innodb的多版本特性，这个表的修改对其他事物不可见，导致这个表的任何查询都不会被缓存，长时间运行事物，会大大降低缓存命中率

如果查询缓存使用了大量内存，缓存失效可能是一个很大的瓶颈

# 什么情况下查询缓存能发挥作用

只要查询缓存带来的**效率提升**大于查询缓存的消耗就可以使用查询缓存，命中率%30也可以

==缓存未命中的原因==：
- 查询语句无法被缓存，包含不确定的函数或者查询结果太大，会导致`qcache_nocache`增加
- mysql从未处理过，不存在缓存
- 虽然之前缓存了查询结果，但是缓存的内存用完了，需要将某些缓存逐出，或者数据表修改导致缓存失效

==存在大量缓存未命中，实际大多数查询被缓存造成的原因==：
- 查询缓存还没有预热
- 查询语句从未执行过
- 缓存失效操作太多

> 总结：mysql 收到一条sql，判读是否以`sel`开头，然后对sql生成hash值，判读缓存引用表中是否存在缓存，所以sql有任何字符的不同都会无法命中，无法命中mysql会解析、优化、执行sql，查询完成之后，如果sql中存在任何函数、变量、临时表、权限或者查询结果太大都会导致查询结果无法被缓存

== 直观的判断缓存命中效率 ==
命中和写入的比率 `Qcache_hint`和`Qcache_insert`的比例，达到3:1通常有效，最好能达到10：1

# 配置mysql缓存

- `query_cache_type` 
    - off
    - on
    - demand 只有在查询中写明`sql_cache`语句才放入查询缓存，可以是会话级别，也可以是全局级别
- `query_cache_size` \
查询使用总空间，单位是1024,这个值必须是1024整数倍，否则可能数值会不一致
- `query_cache_min_res_unit` \
内存分配块的最小单位
- `query_cache_limit` \
能够缓存的最大查询结果，查询结果大于这个值就不会缓存，查询缓存在数据生成的时候就开始尝试缓存数据,只有结果全部返回后，才知道查询结果是否超出限制，如果超出增加状态值`Qcache_no_cached`,如果提前知道可以在sql中加入`sql_no_cache`避免查询缓存带来的额外消耗
- `query_cache_wlock_invalidate`\
某个数据表被其他链接锁住，是否任然从缓存中返回查询结果，默认是off

# 维护缓存

## 观察碎片: 

`Qcache_free_blocks`

最糟糕的情况是: 任何两个存储数据块之间都有一个非常小的碎片,如果 `Qcache_free_blocks` 恰好达到 `Qcache_total_blocks/2`，碎片就会很严重，如果空闲块很多，`Qcache_lowmem_prunes` 状态值不断增加，说明碎片导致缓存过早的删除了缓存结果
> prunes: 精简，修减


## 减少碎片
设置合理的`Qcache_cache_min_res_unit`,可以减少碎片，太小，浪费空间更少，但会导致更频繁的内存申请操作；太大, 浪费空间更多。这个值和
查询结果大小有关。

==计算单个查询的平均大小==
```
Query_cache_size - Qcache_free_memery 

/

Qcache_queries_in_cache
```
如果查询缓存的大小跟不均匀，碎片和反复的内存分配无可避免

如果发现缓存一个非常大的结果意义不大，可以设置 `Query_cache_limit` 的大小

## 整理碎片

`flush_query_cache`完成整理碎片，会将所有的查询缓存排序，并将所有的空闲块整理到一块，这个命令不会清除缓存，`flush_query_cache`
会访问所有的缓存其他所有的链接都无法查询缓存，会导致服务器僵死一段时间，建议保持查询空间足够小，以便维护时，使僵死的时间短

`Reset_query`cache` 可以清空缓存

## 提高查询缓存的使用效率

如果查询缓存不再存在缓存问题，命中率仍然很低，可能是查询空间太小导致，如果mysql缓存新的查询缓存时就会删除老的缓存，可以通过查看

`Qcache_lowmem_prunes` 查看状态值\
`Qcache_free_memory` 查看空闲内存