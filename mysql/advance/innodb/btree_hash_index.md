# Btree 和 hash 索引的区别

## B+tree

B+tree 从根节点到每个叶子节点的高度差不会超过1，同级节点之间有指针相互连接

B+tree 常规检索，从根节点到叶子节点搜索效率基本相当，基于顺序扫描时，可以利用双向指针左右移动，效率很高

在primary index中存放的是表的实际数据，包括主键和其他字段的数据，以主键的值有序排列，secondary index的leaf node中存放了索引列的相关信息，还存放了主键的值。

通过clustered index访问数据的话，会非常快，如果通过secondary index访问数据，需要通过索引找到leaf node,然后通过里面的主键值在通过主键索引过去到相应的数据行

MyISAM的clustered index和secondary index的差别很小，只是主键索引的值是一个唯一且非空的键

MyISAM的索引和InnoDB的secondary index数据结构基本一致，区别是MyISAM在leaf node上存放索引键信息，在存放能直接定位的数据文件数据行的信息(row no) ,并不会存放主键值信息

## hash

> 哈希表： 数据哈希地址 = f(关键字的值)
> 哈希地址只是表示只是表示数据在查找表中的存储位置，不是实际的物理存储位置，f()是一个函数，通过这个函数可以求出关键字对应的数据哈希地址

hash索引的检索可以一次定位，不像B+tree索引，从根节点到叶节点多次的io访问，hash索引查询效率选高于B+tree索引

- hash索引只包含hash值和行指针
- hash索引不是按照索引值顺序存储的，不能进行排序，满足 `=` `in` `<=>` 查询，不能使用范围查询，hash索引比较的是运算以后的值
- 不能利用部分索引键查询，hash在计算hash值时，是组合索引键组合在一起后计算，如(a,b)联合索引，只查找a无法使用
- hash查找速度是非常快的，除非很多hash冲突，出现冲突必须遍历所有行比较
- hash冲突很多的话，索引维护操作代价也会很高，遍历hash值得每一行，找到对应的然后再删除

# 我就试试