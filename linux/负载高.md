---
Title: 服务器负载高问题排查思路
Keywords: 负载高,问题排查,load average,CPU密集型,IO密集型
Description: 借助stress、iostat、mpstat、pidstat定位负载高的进程
Label: 高负载
Date: 2020-08-07 10:37:00
LastEditTime: 2020-08-07 10:37:00
---

[toc]

# Linux 负载含义

#### 单核处理器, 只有一个
"load average"的值越低，比如等于0.2或0.3，就说明电脑的工作量越小，系统负荷比较轻。

系统负荷为1.0，意味着大桥的所有路段都有车，也就是说大桥已经"满"了。但是必须注意的是，直到此时大桥还是能顺畅通行的

系统负荷为1.7，意味着车辆太多了，大桥已经被占满了（100%），后面等着上桥的车辆为桥面车辆的70%。

CPU的系统负荷，基本上等同于上面的类比。大桥的通行能力，就是CPU的最大工作量；桥梁上的车辆，就是一个个等待CPU处理的进程（process）。

#### 经验法则
当系统负荷持续大于0.7，你必须开始调查了，问题出在哪里，防止情况恶化。

当系统负荷持续大于1.0，你必须动手寻找解决办法，把这个值降下来。

当系统负荷达到5.0，就表明你的系统有很严重的问题，长时间没有响应，或者接近死机了。你不应该让系统达到这个值。

#### 多处理器
2个CPU表明系统负荷可以达到2.0，此时每个CPU都达到100%的工作量。推广开来，n个CPU的电脑，可接受的系统负荷最大为n.0

#### 工具

```
$ uptime
11:21:21 up 9 days, 35 min,  5 users,  load average: 1.35, 2.37, 2.60

$ top
load average: 1.35, 2.37, 2.60
```

# 负载与CPU

- CPU密集型进程: 使用大量CPU会导致平均负载高，与平均负载一致
- I/O密集型: 等待I/O也会导致平均负载升高，但是CPU使用率不一定很高
- 上下文切换: 大量的上下文切换也会导致CPU负载变高，此时CPU 使用率也会比较高

## 工具

### Stress:  (模拟负载高的场景) 

> 详细用法来自： [sparkdev](https://www.cnblogs.com/sparkdev/p/10354947.html)

 - `-v`: verbose 详情

 - `-q`: quiet  程序在运行的过程中不输出信息

 - `-n`: dry-run 演练，并不实际执行

 - `-t`: timeout 超时

 - `-c`: 多少进程计算sqrt(平方根)

 - `-i`: 多少进程调用sync(脏页同步到磁盘)

 - `-m`: 多少进程调用内存malloc/free(内存申请释放)

    - `--vm-bytes B`  每个进程总计申请多少字节内存

    - `--vm-stride B`  内存赋值时间隔多少字节

      不断的给部分内存赋值，让 COW(Copy On Write)发生。只要指定了内存相关的选项，这个操作就会执行，只是大小为默认的 4096。赋值内存的比例由参数决定：

      ```
      for (i = 0; i < bytes; i += stride)
          ptr[i] = 'Z';           /* Ensure that COW happens.  */
      ```

      bytes 为消耗的总内存大小，stride 为间隔。
      该参数会影响 CPU 状态 us 和 sy：

      - us: 用户空间占用CPU百分比
      - sy: 内核空间占用CPU百分比

      qweqwe

      ```
      $ stress --vm 2 --vm-bytes 500M --vm-stride 64
      $ top
      %Cpu(s): 21.3 us, 32.1 sy
      ```

      ```
      $ stress --vm 2 --vm-bytes 500M --vm-stride 1M
      $ top
      %Cpu(s):  0.7 us, 36.3 sy
      ```

      --vm-stride 值增大就意味着减少赋值，用户空间占用CPU的比率就小了

   - `--vm-hang N`: 每个消耗内存的进程在分配到内存后转入睡眠状态 N 秒，然后释放内存，一直重复执行这个过程, CPU空闲出来了，US就会降低了

   - `--vm-keep`: 一直占用内存，区别于不断的释放和重新分配(默认是不断释放并重新分配内存)

     ```
     $ stress --vm 2 --vm-bytes 500M --vm-keep
     %Cpu(s): 50.4 us,  0.3 sy
     
     $ stress --vm 2 --vm-bytes 500M --vm-hang 5
     %Cpu(s):  1.8 us,  7.8 sy
     ```

- `-d`: （`--hadd`） 产生 N 个不断执行 write 和 unlink 函数的进程(创建文件，写入内容，删除文件)

  - `--hadd-bytes B`  指定文件大小

## 场景一：CPU密集型

