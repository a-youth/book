# c 内存区域：栈、堆和静态区
## 堆(heap)
由malloc系列函数或new操作符分配的内存，生命周期由free和delete决定，在没有释放之前一致存在，知道程序结束

## 栈(stack/堆栈)
保存局部变量，栈上的内容只在函数范围内生效，当函数运行结束，这些内容也会被自动释放，特点是效率高，空间大小有限

## 静态区域
保存自动全局变量和static变量(包括static全局和局部变量)，静态区的内容在总个程序的生命周期内都存在，由编译器编译时分配


# 数据结构
学习方法：
1. 数据结构图形化、视觉化，直觉上感受一个数据结构，使用它是什么感觉
2. 什么时候用数据结构和算法，不是一开始就陷入到细节中去

# [链表](https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8#%E5%9D%97%E7%8A%B6%E9%93%BE%E8%A1%A8)
链表是线性表，每一个节点存储下一个节点的指针，插入是O(1)复杂度，查找一个元素需要O(n)的时间，顺序表的复杂度是O(log n)和O(1)，克服数组需要提前需要知道数组大小的缺点，可以
充分利用内存空间，但是失去了数组随机读取的优点，同时增加了指针域，空见开销比较大

### 单向链表
包含两个域：
- 信息域
- 指针域
  
![](./assert/Singly-linked-list.svg)

### 双向链表
包含3个域
- 前缀节点
- 信息域
- 后缀节点

![](./assert/Doubly-linked-list.svg)

### 循环链表
首节点和末节点被连接在一起, 包含两个域：
- 信息域
- 指针域

![](./assert/Circularly-linked-list.svg)


# [二叉查找树(binary search tree)](https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9)
二叉搜索树相比与其他数据结构优势子在于查找和插入的时间复杂度较低O(log n),

特点：
- 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；
- 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；
- 任意节点的左、右子树也分别为二叉查找树；
- 没有键值相等的节点；

## 查找算法
查找X的过程：
- 若B是空树，则搜索失败，否则
- 若X等于B的根节点的值域的值，则查找成功，否则：
- 如果X大于B的根节点的值域的值，则查找右子树，否则：
- 查找左子树

## 插入算法
B树中，插入节点S的过程：
- 若B是空树，则将S所指节点作为根节点返回，否则：
- 若S->data等于B节点的值域的值则返回，否则：
- 若S->data小于B节点的值域的值，则把S节点插入左子树中，否则：
- 把S所指节点插入右子树中，新插入节点总是叶子节点

## 删除算法
分三种情况讨论：
1. 若S节点为叶子节点，删除叶子节点对整棵树的结构没有影响，free这个节点，修改双亲节点的指向即可；
2. 如果S节点只有左子树SL或右子树SR，只需让SL或SR直接成为其双亲节点的左子树或右子树即可；
3. 如果S节点同时有左子树或右子树，可以按照中序遍历有序进行调整
   1. 令左子树的最右下节点或者右子树的最左下节点
   2. 令它的直接前驱或直接后继代替，在从二叉树中删除它的直接前驱或直接后驱

# [AVL树](https://zh.wikipedia.org/wiki/AVL%E6%A0%91)
任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树, 查找、插入和删除在平均和最坏情况下的时间复杂度都是 O(log n)

![](./assert/Tree_Rebalancing.png)

## 删除
从avl树中删除节点可以把删除的节点向下旋转成一个叶子节点，直接移除这个叶子节点来完成，在旋转成叶子节点过程中做多有log n个节点被旋转， 删除在整体上耗费O(log n)时间

## 搜索
和普通二叉树一样，耗费O(log n)

## 实现描述
假设平衡因子是左子树的高度减去右子树的高度所得到的值\
假设由于在二叉排序树上插入节点而失去平衡的最小子树根节点的指针为a（即a是离插入点最近，且平衡因子绝对值超过1的祖先节点）

失去平衡后的规律：
1. 单向右旋平衡处理LL：由于在*a的左子树根节点的左子树上插入节点，*a的平衡因子由1增至2，致使以*a为根的子树失去平衡，则需要进行一次右旋操作
2. 单向左旋平衡处理RR：由于在*a的右子树根节点的右节点上插入节点，*a的平衡因子由-1变为-2，致使以*a为根的子树失去平衡，则需要进行一次左旋操作
3. 双向旋转（先左后右）平衡处理LR：由于在*a的左子树根节点的右子树上插入节点，*a的平衡因子由1增至2，致使以*a为根的子树失去平衡，则需进行两次旋转（先左旋后右旋）操作。
4. 双向旋转（先右后左）平衡处理RL：由于在*a的右子树根节点的左子树上插入节点，*a的平衡因子由-1变为-2，致使以*a为根的子树失去平衡，则需进行两次旋转（先右旋后左旋）操作。

# 红黑树
红黑树和AVL树一样都对插入时间、删除时间、和查找时间提供了最好可能的最坏情况担保，

他们是最常用的持久数据结构，他们用来构造关联数组和集合，每次插入、删除之后他们能保持为以前的版本，

红黑树相对于AVL树来说，牺牲了部分平衡行以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树

红黑树并不追求完全平衡-只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能

## 时间复杂度
查询O(log n),红黑树的持久版本对每次插入或删除需要O(log n)的空间,每次插入活删除需要O(log n)的空间

## 用途
- 关联数组

## 特点

1. 节点是红色或黑色
2. 根是黑色
3. 所有叶子都是黑色
4. 如果一个节点是黑色的，则它的子节点必须是黑色的
5. 从任意节点到其每个叶子的所有简单路径都包含相同数据的黑色节点

![](./assert/Red-black_tree_example.svg)

需要主意的是：
- 特点3，叶子节点只为空(NULL)节点
- 特点5，确保没有一条路径会比其他路径长出两倍，因而红黑树是相对接近平衡的二叉树

