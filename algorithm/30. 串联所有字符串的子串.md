---
Title: 力扣30题：串联所有单词的子串（go）
Description: 给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。
Keywords: 串联所有单词的子串
Date: 2020-05-17 22:01:18
LastEditTime: 2020-05-17 22:01:32
---

# 题目描述

给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。

注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。

**示例 1：**

```
输入：
  s = "barfoothefoobarman",
  words = ["foo","bar"]
输出：[0,9]
解释：
从索引 0 和 9 开始的子串分别是 "barfoo" 和 "foobar" 。
输出的顺序不重要, [9,0] 也是有效答案。
```

**示例 2：**

```
输入：
  s = "wordgoodgoodgoodbestword",
  words = ["word","good","best","word"]
输出：[]
```

# 思路

1. 判断字符串是否包含words子串
   1. 单词顺序不一定
   2. 单词长度相同
2. 滑动窗口
   1. 长度等于words所有字符的长度  i < len(s) - len(word) * len(words)
   2. 每次往后挪动一个字节，判断是否包含子串

# 代码

```go
func findSubstring(s string, words []string) []int {
	res := make([]int, 0)
	if len(words) == 0 {
		return res
	}
	windowLength := len(words[0]) * len(words)
	for j := 0; j < len(s) && (len(s)-j) >= windowLength; {
		if includeSubStr(s[j:j+windowLength], words) {
			res = append(res, j)
		}
		j++
	}
	return res
}

func delSlice(t []string, i int) []string {
	if i == len(t) {
		return t[:i]
	} else {
		return append(t[:i], t[i+1:]...)
	}
}

func copySlice(src []string) []string {
	dst := make([]string, len(src))
	copy(dst, src)
	return dst
}

func includeSubStr(s string, words []string) bool {
  // 复制切片，直接操作的话会影响原切片
	t := copySlice(words)
	i := 0
	for len(t) > 0 && i < len(s) {
		prev := len(t)
    // 判断是否包含word
		for k, word := range t {
			if s[i:i+len(word)] == word {
				i += len(word)
				t = delSlice(t, k)
				break
			}
		}
		if len(t) == prev {
			return false
		}
	}
	if len(t) == 0 {
		return true
	}
	return false
}
```



