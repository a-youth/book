### 协程、线程、进程

进程：系统分配资源的基本单位

线程：cpu调度和分派的基本单位

协程：用户态轻量级线程，调度由用户控制

**goroutine和线程的区别**
- 调度: os线程调度切换有cpu决定，go有自己的调度器，M:N调度可以将M个gouroutine绑定到N个os系统线程上
- 内存: os线程的栈内存，一般是2M，goroutine的初始化栈内存是2kB，而且客扩展
- 

### 并发模型

不要用共享内存来通信，要用通信来共享内存

goroutine是go的执行单位， channel是goroutine之间的通信机制

**3种并发模型**

- 无缓冲channel
- sync.WaitGroup
- context.Context

**限制goroutine并发数量**
有缓冲channel

### 锁

**互斥锁**: sync.Mutex

**读写锁**: sync.RWMutext

死锁: bing

**分布式锁**： 

分布式锁的条件:

- 分布式系统环境下，一个方法同一时间只能被一个机器的一个线程执行
- 高可用、高性能的获取锁与释放锁
- 具备可重入机制
- 具备锁失效机制，防止死锁
- 具备非阻塞锁的机制，没有获取到锁将直接返回

CAP理论

- 一致性
- 可用性
- 分区容错性

分布式锁的实现

- 数据库
- 基于缓存(redis, memcached, tair)
- 基于Zookeeper实现

### gc

**推荐阅读**

- https://github.com/KeKe-Li/For-learning-Go-Tutorial/blob/master/src/spec/02.0.md

**四个阶段**

- 栈扫面(STW)
- 第一次标记(并发)
- 第二次标记(STW)
- 清除(并发)

